# Изоляция
**Транзакцией** называется последовательность операций, выполняемая приложением, которая переводит базу данных из одного корректного  состояния в другое корректное состояние (согласованность)при условии, что транзакция выполнена полностью (атомарность)и без помех со стороны других транзакций (**изоляция**).
Реализация полной изоляции — сложная задача, сопряженнаяс уменьшением пропускной способности системы. На практике как правило применяется именно ослабленная изоляция.
Стандарт SQL определяет четыре уровня изоляции, описывая аномалии:
- Самый слабый уровень — **Read Uncommitted**, который (как следуетиз названия) позволяет увидеть даже незафиксированные данные
- **Read Committed** должен предотвращать потерянные обновления
- **Repeatable Read**
- **Serializable**

В данной лабораторной работе последовательно реализованы следующие задачи:
#### 1. Фантомное чтение на уровне Read Committed
Создал БД mvcc_isolation
```sh
CREATE DATABASE mvcc_isolation;
```
Соеденился с ней и создал там пустую таблицу:
```sh
\c mvcc_isolation
=# CREATE TABLE foo(id integer);
```
<br>

![Снимок экрана (145)](https://user-images.githubusercontent.com/114056557/206903003-5f7956fc-d62f-4216-ab00-c08a59e83366.png)
<br>

Начнем транзакцию Read Committed и выполним запрос:<br>

![Снимок экрана (146)](https://user-images.githubusercontent.com/114056557/206903043-82d0f81a-3e3f-420e-8c17-4b497fe46b9d.png)

Вставим новую строку в таблицу (изменения фиксируются):<br>

![Снимок экрана (147)](https://user-images.githubusercontent.com/114056557/206903064-9daee956-ae89-4ce2-8c4b-f70b27415a6b.png)

Транзакция **Read Committed** видит добавленную строку.
Отличие от аномалии неповторяющегося чтения (при которой транзакция видит зафиксированные изменения в уже существовавших строках) состоит в том, что здесь видны строки, которых не было раньше.<br>
#### 2. Транзакционность DDL
Откроем транзакцию, удалим таблицу foo, после чего транзакцию откатим:<br>

![Снимок экрана (148)](https://user-images.githubusercontent.com/114056557/206903093-bedecf40-ef1c-4f1d-899a-35acad2b242d.png)


<br>
Таблица по-прежнему существует:
<br>

![Снимок экрана (149)](https://user-images.githubusercontent.com/114056557/206903107-e11898de-f55b-4f5b-9f06-4d111ef12c52.png)

#### 3. Момент, на который видны данные
Открываем транзакцию **Repeatable Read**:
Удаляем строку (изменение фиксируется):<br>

![Снимок экрана (150)](https://user-images.githubusercontent.com/114056557/206903128-1fd42748-0067-4276-9591-c08438e97b4e.png)


Проверяем содержимое таблицы в открытой транзакции:<br>

![Снимок экрана (151)](https://user-images.githubusercontent.com/114056557/206903134-10e3b0ab-8ac1-420a-b862-907294d6c884.png)

Почему строка не видна? Дело в том, что в транзакции Repeatable Read (и Serializable) данные видны на момент начала первой команды, а не на момент выполнения оператора BEGIN.
Завершим транзакцию, вернем строчку и повторим эксперимент.<br>

![Снимок экрана (152)](https://user-images.githubusercontent.com/114056557/206903152-3418bd26-5237-4bc6-a465-3006690a279e.png)


#### 4. Изоляция и системный каталог
Начнем транзакцию Repeatable Read и выполним запрос и создадим таблицу:
<br>

![Снимок экрана (153)](https://user-images.githubusercontent.com/114056557/206903167-2797c32a-59e6-4067-b79a-0e19e4237f92.png)


<br>
Строки таблицы не видны в данном сеансе транзакции,завершим его и просмотрим снова:<br>

![Снимок экрана (154)](https://user-images.githubusercontent.com/114056557/206903177-ef76874a-83a8-44b4-b4f3-fad1d2c9a2e0.png)


Cтроки только что созданной таблицы подчиняются обычным правилам изоляции. Они будут видны только в новой транзакции.
